# Load prerequisites
library(Seurat)
library(tidyverse)
library(msigdbr)
library(readxl)
library(ggvenn)
library(DEP)
library(fgsea)
library(harmony)
library(Azimuth)
library(mclust)
library(enrichR)
library(DEP)
library(ggfortify)
library(ggrepel)
library(xlsx)
library(pheatmap)
library(Scissor)
library(CellChat)
library(patchwork)
library(monocle3)
library(SeuratWrappers)


# Set the working Directory
setwd("<YOUR DATA PATH>")

#Read in the data for the 4 samples
D25P0 <- Read10X("./Donor25P0/filtered_feature_bc_matrix/")
Ctrl <- Read10X("./Donor25Ctrl/filtered_feature_bc_matrix")
Stim <- Read10X("./Donor25Stim/filtered_feature_bc_matrix")

# Create Seurat Objects using the imported data
D25P0 <- CreateSeuratObject(D25P0, min.features = 100)
D25P0$orig.ident <- "D25P0"
Ctrl <- CreateSeuratObject(Ctrl, min.features = 100)
Ctrl$orig.ident <- "Ctrl"
Stim <- CreateSeuratObject(Stim, min.features = 100)
Stim$orig.ident <- "Stim"

# QC the Seurat Objects
# First, calculate the percent mitochondrial DNA in each Seurat object
D25P0[["percent_mito"]] <- PercentageFeatureSet(D25P0, pattern = "^MT-")
Ctrl[["percent_mito"]] <- PercentageFeatureSet(Ctrl, pattern = "^MT-")
Stim[["percent_mito"]] <- PercentageFeatureSet(Stim, pattern = "^MT-")

# Get the maximum and minimum 5 percentile thresholds for nCount and nFeature across 
# All Seurat objects for removing low quality cells and doublets
nCounts <- as.numeric(c(D49P0$nCount_RNA, D25P0$nCount_RNA, Ctrl$nCount_RNA, Stim$nCount_RNA))


nFeatures <- as.numeric(c(D49P0$nFeature_RNA, D25P0$nFeature_RNA, 
                          Ctrl$nFeature_RNA, Stim$nFeature_RNA))


# Pre-QC visualizations for each sample
D25P0_QC <- VlnPlot(D25P0, features = c("nFeature_RNA", "nCount_RNA", "percent_mito"), ncol = 3)+theme(aspect.ratio = 1)
Ctrl_QC <- VlnPlot(Ctrl, features = c("nFeature_RNA", "nCount_RNA", "percent_mito"), ncol = 3)+theme(aspect.ratio = 1)
Stim_QC <- VlnPlot(Stim, features = c("nFeature_RNA", "nCount_RNA", "percent_mito"), ncol = 3)+theme(aspect.ratio = 1)

# Save
setwd("<YOUR RESULTS DIRECTORY>")
ggsave("D25P0_QC.pdf", D25P0_QC, device = "pdf")
ggsave("Ctrl_QC.pdf", Ctrl_QC, device = "pdf")
ggsave("Stim_QC.pdf", Stim_QC, device = "pdf")
write.csv(Ctrl@meta.data[,1:4], file = "Ctrl.QC.csv")
write.csv(Stim@meta.data[,1:4], file = "Stim.QC.csv")
write.csv(D25P0@meta.data[,1:4], file = "P0.QC.csv")

# Subset the objects to remove the low quality cells
# Identify the thresholds to filter on
quantile(nCounts, probs = c(.05, .95))
quantile(nFeatures, probs = c(.05, .95))

# Get the pre-filtering dimensions
dim(D25P0)
dim(Ctrl)
dim(Stim)

# Filter and get post-filtering dimensions
D25P0 <- subset(D25P0, subset = nFeature_RNA > 952 & nFeature_RNA < 7971.35 & 
                 nCount_RNA >1899.95 & nCount_RNA < 67416.35 & percent_mito < 20)
dim(D25P0)
Ctrl <- subset(Ctrl, subset = nFeature_RNA > 952 & nFeature_RNA < 7971.35 & 
                 nCount_RNA >1899.95 & nCount_RNA < 67416.35 & percent_mito < 20)
dim(Ctrl)
Stim <- subset(Stim, subset = nFeature_RNA > 952 & nFeature_RNA < 7971.35 & 
                  nCount_RNA >1899.95 & nCount_RNA < 67416.35 & percent_mito < 20)
dim(Stim)

#Go through iterations to generate a UMAP of the cultured loaded data
Cultured <- NormalizeData(Cultured)
Cultured <- FindVariableFeatures(Cultured, 
                                 selection.method = "vst", nfeatures = 2000)
Cultured <- ScaleData(Cultured, features = VariableFeatures(Cultured))
Cultured <- RunPCA(Cultured, features = VariableFeatures(object = Cultured))

#Integrate the layers of Cultured using Harmony
Cultured <- IntegrateLayers(Cultured, method = "HarmonyIntegration")

# Integrate the datasets using Harmony
Cultured <- RunHarmony(Cultured, group.by.vars = "orig.ident")

# Check to ensure that the number of PCA dimensions explains most of data
ElbowPlot(Cultured)

# Generate a UMAP for Cultured
Cultured <- FindNeighbors(Cultured, dims = 1:10)
Cultured <- FindClusters(Cultured, resolution = 0.5)
Cultured <- RunUMAP(Cultured, dims = 1:10)
DimPlot(Cultured, reduction = "umap")
DimPlot(Cultured, group.by = "orig.ident", reduction = "umap", shuffle = T)

# Save the coordinates
Cultured_UMAP_coords <- as.data.frame(Cultured[["umap"]]@cell.embeddings)
write.table(Cultured_UMAP_coords, "Cultured_UMAP_coords.tsv", quote = F, sep = "\t")

# Cell Cycle scoring of the Cultured cells
s.genes <- cc.genes.updated.2019$s.genes
g2m.genes <- cc.genes.updated.2019$g2m.genes

Cultured <- JoinLayers(Cultured)

Cultured <- CellCycleScoring(Cultured, s.features = s.genes, 
                             g2m.features = g2m.genes, set.ident = TRUE)

f <- DimPlot(Cultured, reduction = "umap", group.by = "Phase")+ theme(aspect.ratio = 1)
ggsave("Cultured by cell cycle.pdf", f, device = "pdf")

# Regress out the effects of cell cycle and try again
Cultured <- ScaleData(Cultured, vars.to.regress = c("S.Score", "G2M.Score"), features = VariableFeatures(Cultured))
Cultured <- RunPCA(Cultured, features = VariableFeatures(object = Cultured))
ElbowPlot(Cultured)
Cultured <- FindNeighbors(Cultured, dims = 1:10)
Cultured <- FindClusters(Cultured, resolution = 0.1)
Cultured <- RunUMAP(Cultured, dims = 1:15)

# UMAPs by cell cycle and cluster
g <- DimPlot(Cultured, reduction = "umap", group.by = "Phase", shuffle = T)+ theme(aspect.ratio = 1)
h <- DimPlot(Cultured, reduction = "umap")+ theme(aspect.ratio = 1)

# Save the post cell cycle-regression UMAP coordinates
Cultured_UMAP_coords_postregress <- as.data.frame(Cultured[["umap"]]@cell.embeddings)
write.table(Cultured_UMAP_coords_postregress, "Cultured_UMAP_coords_postregress.tsv", quote = F, sep = "\t")

# Save images
ggsave("Cultured by cell cycle_post regression.pdf", g, device = "pdf")
ggsave("Cultured by cluster post regression.pdf", h, device = "pdf")


#Continue to generate UMAP for P0D25 Alone
D25P0 <- NormalizeData(D25P0)
D25P0 <- FindVariableFeatures(D25P0, 
                              selection.method = "vst", nfeatures = 2000)
D25P0 <- ScaleData(D25P0, features = VariableFeatures(D25P0))
D25P0 <- RunPCA(D25P0, features = VariableFeatures(object = D25P0))

# Check PCA results
ElbowPlot(D25P0)

# Clustering and UMAP
D25P0 <- FindNeighbors(D25P0, dims = 1:15)
D25P0 <- FindClusters(D25P0, resolution = 0.5)
D25P0 <- RunUMAP(D25P0, dims = 1:10)

# Check Cell Cycle
D25P0 <- CellCycleScoring(D25P0, s.features = s.genes, 
                 g2m.features = g2m.genes, set.ident = TRUE)
DimPlot(D25P0, reduction = "umap")+theme(aspect.ratio = 1)
DimPlot(D25P0, reduction = "umap", group.by = "Phase", shuffle = T)+ theme(aspect.ratio = 1)

# Save D25P0 UMAP coordinates
D25P0_UMAP_coords <- as.data.frame(D25P0[["umap"]]@cell.embeddings)
write.table(D25P0_UMAP_coords, "D25P0_UMAP_coords.tsv", quote = F, sep = "\t")

#Look at the merged dataset by sample
c <- DimPlot(Cultured, reduction = "umap", group.by = "orig.ident") + theme(aspect.ratio = 1)
d <- DimPlot(Cultured, reduction = "umap") + theme(aspect.ratio = 1)
e <- DimPlot(D25P0, reduction = "umap") + theme(aspect.ratio = 1)

# Saave UMAPs
ggsave("Cultured_byorigident.pdf", c, device = "pdf")
ggsave("Cultured_bycluster.pdf", d, device = "pdf")
ggsave("D25P0_bycluster.pdf", e, device = "pdf")

# Clean up the environment
rm(list = c("a", "b", "c", "d", "e", "f", "g", "h", "D49P0_QC", "D25P0_QC", "Ctrl_QC", "Stim_QC",
            "s.genes", "g2m.genes"))
rm(list = c("Cultured_UMAP_coords", "Cultured_UMAP_coords_postregress", "D25P0_UMAP_coords",
            "P0_UMAP_coords", "nCounts", "nFeatures"))

# Save analyzed data thus far
# setwd("<YOUR DATA PATH>")
#save.image(file = "scAnalysis.rdata")

# Load data after saving to skip these initial steps
# setwd("<YOUR DATA PATH>")
load("./scAnalysis.rdata")

###################################################################
# Cluster analysis for Cell type annotation, D25 P0

# SVector of resolutions to test
resolutions <- seq(0.1, 2.0, by = 0.1)

# For each resolution, fund clusters and save a plot of the UMAP at that clustering resolution
for (res in resolutions) {
  print(res)
  D25P0 <- FindClusters(D25P0, resolution = res)
  D25P0[[paste0("cluster_res_", res)]] <- Idents(D25P0)
  ggsave(paste0("D25P0_clusters_", as.character(res), ".pdf"), DimPlot(D25P0, group.by = paste0("cluster_res_", res))+theme(aspect.ratio = 1), device = "pdf")
}

# Initialize an adjusted rand index matrix
ari_matrix <- matrix(NA, nrow = length(resolutions), ncol = length(resolutions),
                     dimnames = list(resolutions, resolutions))

# Loop through pairwise resolutions
for (i in seq_along(resolutions)) {
  for (j in seq_along(resolutions)) {
    cluster1 <- D25P0[[paste0("cluster_res_", resolutions[i])]]
    cluster2 <- D25P0[[paste0("cluster_res_", resolutions[j])]]
    
    # Compute ARI
    ari_matrix[i, j] <- adjustedRandIndex(as.numeric(unlist(cluster1)), as.numeric(unlist(cluster2)))
  }
}

View(ari_matrix)

# Save the matrix
setwd("<YOUR RESULTS PATH>")
write.csv(ari_matrix, "adjustedrandindex_D25P0.csv")

# For each resolution, print the number of cells per cluster to better narrow down ideal
# Clustering resolution
for (res in resolutions) {
  cluster_sizes <- table(D25P0[[paste0("cluster_res_", res)]])
  print(paste("Resolution:", res))
  print(cluster_sizes)
}

# Annotate the cells using Azimuth
D25P0 <- RunAzimuth(D25P0, reference = "adiposeref")

# For each cluster, identify the cell type most commonly annotated
for(cluster in unique(D25P0@meta.data$RNA_snn_res.0.6)){ # 0.6 deemed most optimal
  print(cluster)
  print(D25P0@meta.data$predicted.celltype.l1[D25P0@meta.data$RNA_snn_res.0.6 == cluster] %>% table())
}

# Assign a cell type to each cluster (resolution 0.6) based on consensus 
D25P0@meta.data$celltype_major <- NA
for(cluster in unique(D25P0$RNA_snn_res.0.6)){
  print(cluster)
  tbl <- as.data.frame(D25P0@meta.data$predicted.celltype.l1[D25P0@meta.data$RNA_snn_res.0.6 == cluster] %>% table())
  D25P0@meta.data$celltype_major[D25P0@meta.data$RNA_snn_res.0.6 == cluster] <- as.character(tbl[which(tbl$Freq == max(tbl$Freq)), 1])
}

unique(D25P0$celltype_major)

# Check consistency of cell type annotations with Liu et al
D25P0.markers <- FindAllMarkers(D25P0, only.pos = TRUE, min.pct = 0.25, 
                                logfc.threshold = 0.25)

# Marker genes from literature
markergenes <- c("PDGFRA", "DCN", "CDH5", "PECAM1", "RGS5", "CSPG4", "CD3D", 
                 "CD3G", "KLRB1", "KLRD1", "CD79A", "IGHG2", "TPSB2", "KIT", 
                 "ITGAM", "CD68", "LY75", "CLEC4C")

# Print clusters that are enriched for these marker genes
for(gene in markergenes){
  print(gene)
  print(unique(D25P0.markers$cluster[D25P0.markers$gene == gene]))
}

# Get a UMAP of the correct clustering resolutions
DimPlot(D25P0, group.by = "cluster_res_0.6")

# Get a list of the markers enriched in each cluster of the same major cell type
for(celltype in unique(D25P0$predicted.celltype.l1)){
  print(celltype)
  if(length(unique(D25P0$RNA_snn_res.0.6[D25P0@meta.data$celltype_major == celltype])) > 1){
    clusts <- unique(D25P0$RNA_snn_res.0.6[D25P0@meta.data$celltype_major == celltype])
    Idents(D25P0) <- "RNA_snn_res.0.6"
    for(cluster in clusts){
      markers <- FindMarkers(subset(D25P0, subset = celltype_major == celltype), ident.1 = cluster)
      markers <- markers[markers$p_val_adj < 0.05,]
      markers$gene <- rownames(markers)
      assign(paste0(celltype, "_", cluster, "_markers"), markers)
    }
  }
}


# Markers APOD, CXCL14, MGP (pre-adipocyte) are in cluster 0
# Markers PRG4 and CLEC3B (fibro-ASC) are in cluster 6
# ASC cluster 12 : ASC_other

print(unique(D25P0$RNA_snn_res.0.6[which(D25P0$celltype_major == "Smooth Muscle")]))
# Cluster 8 is smooth muscle

print(unique(D25P0$RNA_snn_res.0.6[which(D25P0$celltype_major == "Pericyte")]))
#Cluster 4 is pericytes

print(unique(D25P0$RNA_snn_res.0.6[which(D25P0$celltype_major == "T")]))
# Cluster 7 is T cells

print(unique(D25P0$celltype_major[which(D25P0$RNA_snn_res.0.6 == 5)]))
# Cluster 5 is Dendritic cells

print(unique(D25P0$celltype_major[which(D25P0$RNA_snn_res.0.6 == 11)]))
# Cluster 11 is NK cells

# Cluster 9 in venous endothelial cells based on enrichment of markers ACKR1 and VCAM1
# Cluster 3 is lymmphatic endothelial based on enrichment of LYVE1
# Cluster 2 is Endothelial other

# Cluster 1 is an antioxidant mac (HMOX1)
# Cluster 10 is a tissue-resident macrophage

# Final annotations 
D25P0$celltype_final <- D25P0$celltype_major
D25P0$celltype_final[D25P0$cluster_res_0.6 == 0] <- "ASC Pre-adipocyte"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 6] <- "Fibro-ASC"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 12] <- "ASC Other"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 9] <- "Venous Endothelial Cell"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 3] <- "Lymphatic Endothelial Cell"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 2] <- "Endothelial Other"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 1] <- "Anti-Oxidant Macrophage"
D25P0$celltype_final[D25P0$cluster_res_0.6 == 10] <- "Tissue-Resident Macrophage"

unique(D25P0$celltype_final)

# Save the annotated UMAP for D25P0
D25P0_UMAP <- DimPlot(D25P0, group.by = "celltype_final", label = T)+theme(aspect.ratio = 1)
D25P0_UMAP
ggsave("D25P0_annotated_UMAP.pdf", D25P0_UMAP, device = "pdf", width = 8, height = 6)

# Repeat for Cultured
# Save plots at varying resolutions
for (res in resolutions) {
  print(res)
  Cultured <- FindClusters(Cultured, resolution = res)
  Cultured[[paste0("cluster_res_", res)]] <- Idents(Cultured)
  ggsave(paste0("Cultured_clusters_", as.character(res), ".pdf"), DimPlot(Cultured, group.by = paste0("cluster_res_", res))+theme(aspect.ratio = 1), device = "pdf")
}

# Initalize the ARI matrix
ari_matrix <- matrix(NA, nrow = length(resolutions), ncol = length(resolutions),
                     dimnames = list(resolutions, resolutions))

# Loop through pairwise resolutions
for (i in seq_along(resolutions)) {
  for (j in seq_along(resolutions)) {
    cluster1 <- Cultured[[paste0("cluster_res_", resolutions[i])]]
    cluster2 <- Cultured[[paste0("cluster_res_", resolutions[j])]]
    
    # Compute ARI
    ari_matrix[i, j] <- adjustedRandIndex(as.numeric(unlist(cluster1)), as.numeric(unlist(cluster2)))
  }
}

View(ari_matrix)

# Save
setwd("<YOUR RESULTS DIRECTORY>")
write.csv(ari_matrix, "adjustedrandindex_Cultured.csv")

# Optimize further by identifying resolution with sufficient cell numbers per cluster
for (res in resolutions) {
  cluster_sizes <- table(Cultured[[paste0("cluster_res_", res)]])
  print(paste("Resolution:", res))
  print(cluster_sizes)
}

DimPlot(Cultured, group.by = "cluster_res_0.3") # Optimized clustering resolution

# Identify the marker genes for each cluster in Cultured given the optimal clustering resolution
Idents(Cultured) <- "cluster_res_0.3"
Cultured_markers <- FindAllMarkers(Cultured)
Cultured_markers <- Cultured_markers[Cultured_markers$p_val_adj < 0.05,]

# Save
write.csv(Cultured_markers, "Cultured_markers.csv")


# Cell type annotation for Cultured
# Get databases
dbs <- c("GO_Molecular_Function_2015", "GO_Cellular_Component_2015", "GO_Biological_Process_2015")

# Use enrichr to identify biological processes most enriched in each cluster
enriched_0 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 0 & Cultured_markers$avg_log2FC >0], dbs)
enriched_0[["GO_Biological_Process_2015"]]
plotEnrich(enriched_0[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

enriched_4 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 4 & Cultured_markers$avg_log2FC >0], dbs)
enriched_4[["GO_Biological_Process_2015"]]
plotEnrich(enriched_4[[3]], showTerms = 20, numChar = 110, y = "Count", orderBy = "P.value")

enriched_5 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 5 & Cultured_markers$avg_log2FC >0], dbs)
enriched_5[["GO_Biological_Process_2015"]]
plotEnrich(enriched_5[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

enriched_7 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 7 & Cultured_markers$avg_log2FC >0], dbs)
enriched_7[["GO_Biological_Process_2015"]]
plotEnrich(enriched_7[[3]], showTerms = 20, numChar = 150, y = "Count", orderBy = "P.value")

enriched_1 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 1 & Cultured_markers$avg_log2FC >0], dbs)
enriched_1[["GO_Biological_Process_2015"]]
plotEnrich(enriched_1[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

enriched_6 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 6 & Cultured_markers$avg_log2FC >0], dbs)
enriched_6[["GO_Biological_Process_2015"]]
plotEnrich(enriched_6[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

enriched_2 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 2 & Cultured_markers$avg_log2FC >0], dbs)
enriched_2[["GO_Biological_Process_2015"]]
plotEnrich(enriched_2[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

enriched_3 <- enrichr(Cultured_markers$gene[Cultured_markers$cluster == 3 & Cultured_markers$avg_log2FC >0], dbs)
enriched_3[["GO_Biological_Process_2015"]]
plotEnrich(enriched_3[[3]], showTerms = 20, numChar = 100, y = "Count", orderBy = "P.value")

DimPlot(Cultured, group.by = "orig.ident")
DimPlot(Cultured, group.by = "cluster_res_0.3")

# Cluster_0: Inflammatory response ASCs
# Cluster_4: Cycling Inflammatory ASCs
# Cluster_7: Antigen presentation ASCs/TypeI interferon
# Cluster_5: ECM and Cytoskeleton
# Cluster 1: RNA splicing Control ASC
# Cluster 6: GTP Control ASC
# Cluster 2: Translation Control ASC
# Cluster 3: Control RNA splicing 2

# Update cell type annotations in Cultured
Cultured$celltype_final <- NA
Cultured$celltype_final[Cultured$cluster_res_0.3 == 0] <- "Inflammatory response"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 1] <- "RNA splicing control"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 2] <- "Translation control"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 3] <- "RNA splicing control 2"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 4] <- "Cycling inflammatory"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 5] <- "ECM and cytoskeleton"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 6] <- "GTP control"
Cultured$celltype_final[Cultured$cluster_res_0.3 == 7] <- "Antigen presenting"

unique(Cultured$celltype_final)

# Make an annotated UMAP
Cultured_UMAP <- DimPlot(Cultured, group.by = "celltype_final", label = T)+theme(aspect.ratio = 1)
Cultured_UMAP
ggsave("Cultured_annotated_UMAP.pdf", Cultured_UMAP, device = "pdf", width = 8, height = 6)

# Save the single cell data with cell type annotations
# setwd("<YOUR DATA DIRECTORY>)
#save.image(file = "AnnotatedscAnalysis.RData")

##################################################################################
# Dot and Violin Plot Visualization of marker genes for the P0 Seurat Object

# Major cell types
Idents(D25P0) <- "celltype_final"
DimPlot(D25P0, group.by = "celltype_final")+theme(aspect.ratio = 1)
VlnPlot(D25P0, features = c("PDGFRA", "DCN", "RGS5", "CSPG4", "ITGAM", "CD68", 
                            "CDH5", "PECAM1", "CD3D", "CD3G", "KLRD1", "CD1C"), ncol = 4, pt.size = 0)

# ASC-specific genes
ASC_genes <- c("PDGFRA", "DCN", "APOD", "CXCL14", "MGP", "PRG4", "CLEC3B")
names(ASC_genes) <- "ASC"

# Smooth Muscle Genes
Smooth_muscle_genes <- c("ACTA2", "TAGLN", "MYH11")
names(Smooth_muscle_genes) <- "Smooth_muscle"

# Pericyte-like genes
Pericyte_genes <- c("RGS5", "CSPG4")
names(Pericyte_genes) <- "Pericyte"

# NK-like cell genes
NK_genes <- c("KLRD1", "ITGB1")
names(NK_genes) <- "NK"

# Dendritic Cell genes
DC_genes <- c("CD1C", "HLA-DPA1", "HLA-DPB1", "HLA-DRA")
names(DC_genes) <- "DC"

# Macrophage genes
Macrophage_genes <- c("ITGAM", "CD68", "HMOX1")
names(Macrophage_genes) <- "Macrophage"

# Endothelial genes
Endothelial_genes <- c("CDH5", "PECAM1", "ACKR1", "VCAM1", "LYVE1")
names(Endothelial_genes) <- "Endothelial"

# T cell genes
T_genes <- c("CD3D", "CD3G")
names(T_genes) <- "T-Cell"

# Prep for dot plot
genes_for_dotplot <- c(ASC_genes, Pericyte_genes, Endothelial_genes, Macrophage_genes, DC_genes,
                       Smooth_muscle_genes, NK_genes, T_genes)
names(genes_for_dotplot) <- NULL


colors_for_clusters <- c("purple", "purple", "red", "purple", "green", "blue", "hotpink", 
                         "blue", "turquoise", "blue", "hotpink", "grey", "orange")

colors_for_clusters <- c("purple", "purple", "purple", "green", "blue", "blue", "blue", 
                         "hotpink", "hotpink", "grey", "turquoise", "orange", "red")

colors_for_genes <- c(rep("purple", length(ASC_genes)), rep("green", length(Pericyte_genes)),
                      rep("blue", length(Endothelial_genes)), rep("hotpink", length(Macrophage_genes)),
                      rep("grey", length(DC_genes)), rep("turquoise", length(Smooth_muscle_genes)),
                      rep("orange", length(NK_genes)), rep("red", length(T_genes)))



Idents(D25P0) <- "celltype_final"
levels(D25P0)

# P0 dot plot
dotplot_P0 <- DotPlot(D25P0, features = genes_for_dotplot, group.by = "celltype_final", cluster.idents = T,
                      col.min = 0)+ theme(axis.text.x = element_text(size = 26, angle = 45, vjust = 0.5, hjust=1, color =  
                                                                       colors_for_genes))+
  theme(axis.text.y = element_text(size = 26, color = colors_for_clusters))+
  theme(legend.position = "bottom")

dotplot_P0$data$id <- factor(x = dotplot_P0$data$id, levels = c("ASC Pre-adipocyte",
                                                                "Fibro-ASC",
                                                                "ASC Other",
                                                                "Pericyte",
                                                                "Lymphatic Endothelial Cell",
                                                                "Venous Endothelial Cell",
                                                                "Endothelial Other",
                                                                "Tissue-Resident Macrophage",
                                                                "Anti-Oxidant Macrophage",
                                                                "Dendritic",
                                                                "Smooth Muscle",
                                                                "NK",
                                                                "T"))
dotplot_P0
setwd("<YOUR RESULTS PATH>")
ggsave("P0_dotplot.pdf", plot = dotplot_P0, device = "pdf", width = 24, height = 9)
#######################################################################################
# GSEA on scRNAseq, proteomics, and scRNAseq & proteomics together

# Load your annotated data
setwd("<YOUR DATA PATH>")
load("AnnotatedscAnalysis.RData")

# Read in the proteomics data and re-format
proteomics <- read_excel("./Eric-BrownUni-10 Samples comparison-Human-BSA-DB-06-24-2021-All Proteins (1).xlsx")
proteomics_data <- data.frame(proteomics[34:43])
colnames(proteomics_data) <- c("Ctrl_1", "Ctrl_2", "Ctrl_3", "Ctrl_4", "Ctrl_5",
                               "Stim_1", "Stim_2", "Stim_3", "Stim_4", "Stim_5")
rownames(proteomics_data) <- proteomics$Accession
proteomics_data[is.na(proteomics_data)] <- 0

# Change the protein Accession numbers to gene names
names <- read_table("../uniprot-download_true_format_tsv-2023.05.22-16.32.18.17.tsv")
proteomics_data2 <- proteomics_data[rownames(proteomics_data) %in% names$From,]
proteomics_data2$gene <- NA
for(prot_name in unique(names$From)){
  index <- which(rownames(proteomics_data2) == prot_name)
  proteomics_data2$gene[index] <- names$To[which(names$From == prot_name)]
}

# Rename the column names to reflect stimulus and replicate
colnames(proteomics_data2) <- c("Ctrl_1", "Ctrl_2", "Ctrl_3", "Ctrl_4", "Ctrl_5",
                                "Stim_1", "Stim_2", "Stim_3", "Stim_4", "Stim_5", "gene")

# Some proteins have redundant gene names; average those redundancies
prot_data_final <- data.frame(matrix(NA, nrow = 1, ncol = 11))
colnames(prot_data_final) <- c("Ctrl_1", "Ctrl_2", "Ctrl_3", "Ctrl_4", "Ctrl_5",
                               "Stim_1", "Stim_2", "Stim_3", "Stim_4", "Stim_5", "gene")
for(gene in unique(proteomics_data2$gene)){
  if(nrow(proteomics_data2[proteomics_data2$gene == gene,] > 1)){
    avgs <- colMeans(proteomics_data2[proteomics_data2$gene == gene, 1:10])
    avgs <- c(avgs, gene)
    names(avgs) <- gene
    prot_data_final <- rbind(prot_data_final, avgs)
  }
  else(prot_data_final <- rbind(prot_data_final, proteomics_data2[proteomics_data2$gene == gene,]))
}
prot_data_final <- prot_data_final[-1,]

# Copy the data for downstream analysis
prot_data_final2 <- data.frame(sapply(prot_data_final[1:10], as.numeric))
prot_data_final2$gene <- prot_data_final$gene

# Get the average abundances for the proteins for both control and stimulated samples
abundance_ctrl <- data.frame(rowMeans(prot_data_final2[,1:5]))
rownames(abundance_ctrl) <- prot_data_final2$gene
abundance_stim <- data.frame(rowMeans(prot_data_final2[,6:10]))
rownames(abundance_stim) <- prot_data_final2$gene
###################################################################################
# DE gene and protein analysis
# Get the DE genes from sc
Cultured <- NormalizeData(Cultured) %>% ScaleData(.)
Idents(Cultured) <- "orig.ident"
#DimPlot(Cultured)+ theme(aspect.ratio = 1)
ctrlvsstim <- FindMarkers(Cultured, ident.1 = "Stim", ident.2 = "Ctrl")
ctrlvsstim <- ctrlvsstim[ctrlvsstim$p_val_adj < 0.05,]
ctrlvsstim <- ctrlvsstim %>% arrange(-avg_log2FC)

# Get the ranked genes for sc
gene_list <- ctrlvsstim$avg_log2FC
names(gene_list) <- rownames(ctrlvsstim)

# Run GSEA on the DE genes
setwd("<YOUR DATA PATH>")
GO_file <- "h.all.v7.4.symbols.gmt"

# Run fGSEA for the given GO file (Hallmark gmt)
myGO = fgsea::gmtPathways(GO_file)
set.seed(42)
fgRes <- fgsea::fgsea(pathways = myGO, 
                      stats = gene_list,
                      minSize=15,
                      maxSize=600)

fgRes <- fgRes[fgRes$padj < 0.05]

# Repeat for c5
GO_file2 <- "c5.all.v2023.2.Hs.symbols.gmt"

# Run fGSEA for the given GO file (c5 gmt)
myGO2 = fgsea::gmtPathways(GO_file2)
set.seed(42)
fgRes2 <- fgsea::fgsea(pathways = myGO2, 
                      stats = gene_list,
                      minSize=15,
                      maxSize=600)

fgRes2 <- fgRes2[fgRes2$padj < 0.05]

# Merge the results
fgRes <- rbind(fgRes, fgRes2)

setwd("<YOUR RESULTS PATH>")
write.csv(fgRes[,1:7], "scGSEA_results.csv")

# DEP basic pipeline for differential protein abundance
rownames(prot_data_final2) <- prot_data_final2$gene
de_protsdata <- prot_data_final2[,-11]

# For DEP normalize the data by dividing by 10,000, then make integer
de_protsdata2 <- data.frame(sapply(de_protsdata/10000, as.integer))
de_protsdata2$gene <- prot_data_final2$gene
rownames(de_protsdata2) <- rownames(prot_data_final2)

# data
data_unique <- make_unique(de_protsdata2, "gene", "gene", delim = ";")

# annotation index
columns <- 1:10

# Set up
experimental_design <- data.frame(label = c(paste0("Ctrl_", 1:5), paste0("Stim_", 1:5)), condition = c(rep("Ctrl", 5), rep("Stim", 5)),
                                  replicate = c(1:5, 1:5))

# Run DEEP
data_se <- make_se(data_unique, columns, experimental_design)
data_diff <- test_diff(data_se, type = "control", control = "Ctrl")
data_diff2 <- add_rejections(data_diff)
data_results <- get_results(data_diff2)
nrow(data_results[data_results$Stim_vs_Ctrl_p.adj < 0.05,])

# get results and number of significant DEPs
data_results <- na.omit(data_results)
nrow(data_results[data_results$Stim_vs_Ctrl_p.adj < 0.05,])

# Get significant results
DE_prots <- data_results[data_results$Stim_vs_Ctrl_p.adj < 0.05,]
DE_prots <- DE_prots %>% arrange(-Stim_vs_Ctrl_ratio)

# Save the DE prots for later
prots <- DE_prots$Stim_vs_Ctrl_ratio
names(prots) <- DE_prots$name

# Run GSEA on the DEPs
set.seed(42)
fgRes_prot <- fgsea::fgsea(pathways = myGO, 
                           stats = prots,
                           minSize=15,
                           maxSize=600)

fgRes_prot <- fgRes_prot[fgRes_prot$padj < 0.05]

# Repeat for c5
GO_file2 <- "c5.all.v2023.2.Hs.symbols.gmt"

# Run fGSEA for the given GO file (c5 gmt)
myGO2 = fgsea::gmtPathways(GO_file2)
set.seed(42)
fgRes2_prot <- fgsea::fgsea(pathways = myGO2, 
                       stats = gene_list,
                       minSize=15,
                       maxSize=600)

fgRes2_prot <- fgRes2_prot[fgRes2_prot$padj < 0.05]

# Merge the results
fgRes_prot <- rbind(fgRes_prot, fgRes2_prot)

# Save
write.csv(fgRes_prot[,1:7], file = "protGSEA_results.csv")


# transform the data for downstream analyses
genes <- prot_data_final2$gene
proteomics_data2 <- prot_data_final2[,1:10]/10000
prots_for_scissor <- proteomics_data2
rownames(prots_for_scissor) <- genes
proteomics_data2 <- sapply(proteomics_data2, function(x) {
  as.integer(as.character(x))
})
rownames(proteomics_data2) <- prot_data_final2$gene

##########################################################################
# Process the Ctrl and Stim sc data and get pseudobulk averages
Ctrl <- subset(Cultured, subset = orig.ident == "Ctrl")
Stim <- subset(Cultured, subset = orig.ident == "Stim")

Idents(Ctrl) <- "orig.ident"
Idents(Stim) <- "orig.ident"

pseudobulk_ctrl <- as.data.frame(PseudobulkExpression(Ctrl))
pseudobulk_stim <- as.data.frame(PseudobulkExpression(Stim))

# Merge the data on gene names and then run correlation tests on the abundances
cor_df_ctrl <- merge(abundance_ctrl, pseudobulk_ctrl, by = "row.names")
cor_df_stim <- merge(abundance_stim, pseudobulk_stim, by = "row.names")

colnames(cor_df_ctrl) <- c("gene", "proteomics", "scRNAseq")
colnames(cor_df_stim) <- c("gene", "proteomics", "scRNAseq")

cor.test(log1p(cor_df_ctrl$scRNAseq), log1p(cor_df_ctrl$proteomics))
cor.test(log1p(cor_df_stim$scRNAseq), log1p(cor_df_stim$proteomics))

cor_df_ctrl2 <- cor_df_ctrl[cor_df_ctrl$proteomics > 0,]
cor_df_stim2 <- cor_df_stim[cor_df_stim$proteomics > 0,]

# plot
ctrl_cor <- ggplot(cor_df_ctrl2, aes(x = log1p(proteomics), y = log1p(scRNAseq)))+
  geom_point(size = 0.5)+
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")+
  theme(text = element_text(size = 10))+
  xlab("Log Relative Protein abundance")+ ylab("Log Pseudobulk gene expression")

stim_cor <- ggplot(cor_df_stim2, aes(x = log1p(proteomics), y = log1p(scRNAseq)))+
  geom_point(size = 0.5)+
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")+
  theme(text = element_text(size = 10))+
  xlab("Log Relative Protein abundance")+ ylab("Log Pseudobulk gene expression")

setwd("<YOUR RESULTS DIRECTORY>")
ggsave("ctrl_pseudobulk_proteomics_cor.pdf", ctrl_cor, device = "pdf", height = 1.5, width = 2.25)
ggsave("stim_pseudobulk_proteomics_cor.pdf", stim_cor, device = "pdf", height = 1.5, width = 2.25)

# Make the Venn Diagram
vennlist <- list(Proteomics = names(prots), Single_cell = names(gene_list))

p <- ggvenn(vennlist)

ggsave("Venn_diagram.pdf", p, device = "pdf")

# Get the genes that are DE in both sc and proteomics for GSEA
names2 <- Reduce(intersect, vennlist)

# correlate the abundances/expression of the genes DE in both modalities
sc_181_ctrl <- subset(pseudobulk_ctrl, subset = rownames(pseudobulk_ctrl) %in% names2)
prot_181_ctrl <- subset(abundance_ctrl, subset =rownames(abundance_ctrl) %in% names2)
cor_df_ctrl_181 <- merge(sc_181_ctrl, prot_181_ctrl, by = "row.names")
colnames(cor_df_ctrl_181) <- c('rownames', "sc", "prot")

sc_181_stim <- subset(pseudobulk_stim, subset = rownames(pseudobulk_stim) %in% names2)
prot_181_stim <- subset(abundance_stim, subset =rownames(abundance_stim) %in% names2)
cor_df_stim_181 <- merge(sc_181_stim, prot_181_stim, by = "row.names")
colnames(cor_df_stim_181) <- c('rownames', "sc", "prot")

#cor.test(cor_df_ctrl_181$sc, cor_df_ctrl_181$prot)
#cor.test(cor_df_stim_181$sc, cor_df_stim_181$prot)

# Plot the genes expression and protein levels of those 151 genes
ctrl_cor_181 <- ggplot(cor_df_ctrl_181[cor_df_ctrl_181$prot > 0,], aes(x =log1p(prot), y= log1p(sc)))+
  geom_point(size = 0.5)+
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")+
  theme(text = element_text(size = 10))+
  xlab("Log Relative Protein abundance")+ ylab("Log Pseudobulk gene expression")

stim_cor_181 <- ggplot(cor_df_stim_181[cor_df_stim_181$prot > 0,], aes(x = log1p(prot), y = log1p(sc)))+
  geom_point(size = 0.5)+
  stat_smooth(method = "lm",
              formula = y ~ x,
              geom = "smooth")+
  theme(text = element_text(size = 10))+
  xlab("Log Relative Protein abundance")+ ylab("Log Pseudobulk gene expression")

setwd("<YOUR RESULTS PATH>")
ggsave("ctrl_pseudobulk_proteomics_cor_181.pdf", ctrl_cor_151, device = "pdf", height = 1.5, width = 2.25)
ggsave("stim_pseudobulk_proteomics_cor_181.pdf", stim_cor_151, device = "pdf", height = 1.5, width = 2.25)


cor.test(log1p(cor_df_ctrl_181$sc), log1p(cor_df_ctrl_181$prot))
cor.test(log1p(cor_df_stim_181$sc), log1p(cor_df_stim_181$prot))


# Prep for GSEA by making a ranked gene list
gsea_ranklist <- subset(ctrlvsstim, subset = rownames(ctrlvsstim) %in% names2)
gsea_ranklist2 <- gsea_ranklist[order(gsea_ranklist$avg_log2FC, decreasing = T),]
gsea_list <- gsea_ranklist2$avg_log2FC
names(gsea_list) <- rownames(gsea_ranklist2)

# Run GSEA on Hallmarks and GO terms

# Get the hallmark and c5 gene sets
h_gene_sets = msigdbr(species = "human", category = "H")
C5_gene_sets = msigdbr(species = "human", category = "C5")
h_gene_sets = h_gene_sets %>% split(x = .$gene_symbol, f = .$gs_name)
C5_gene_sets = C5_gene_sets %>% split(x = .$gene_symbol, f = .$gs_name)

# Run GSEA
set.seed(42)
gsea_out_h <- fgsea(h_gene_sets, stats = gsea_list)
set.seed(42)
gsea_out_c5 <- fgsea(C5_gene_sets, stats = gsea_list)
gsea_out <- rbind(gsea_out_h[gsea_out_h$padj < 0.05,], gsea_out_c5[gsea_out_c5$padj < 0.05,])

# Save results
df <- apply(gsea_out ,2,as.character)
write.table(df, file = "scandprot_gsea_results.tsv", quote = F, sep = "\t")
#################################################################################
# GSEA plotting for single cell, proteomics, and both

# Load the results
setwd("<YOUR RESULTS PATH>")
both <- read.table("./scandprot_gsea_results.tsv", skip = 1)
sc <- read.csv("scGSEA_results.csv")
prot <- read.csv("protGSEA_results.csv")

# Format
sc$X <- NULL
prot$X <- NULL
colnames(both) <- colnames(sc)

# For each data frame:
for(res in c("sc", "prot", "both")){
  
  # Load data
  GSEA <- get(res)
  
  # Add some additional annotations for plotting
  GSEA$abs <- abs(as.numeric(GSEA$NES))
  
  # Annotate which pathways were enriched in ctrl vs stim (fill color)
  GSEA$enrichment <- NA
  GSEA$enrichment[GSEA$NES < 0] <- "Enriched in Control"
  GSEA$enrichment[GSEA$NES> 0] <- "Enriched in Simulated"
  
  # Y-axis needs a generic label; will only have 1 value
  GSEA$ylabel <- "label"
  
  # Transparency of bubbles indicates significance levels
  GSEA$transparency <- NA
  GSEA$padj <- as.numeric(GSEA$padj)
  GSEA$transparency[GSEA$padj < 0.05 & GSEA$padj >= 0.01] <- 1
  GSEA$transparency[GSEA$padj < 0.01 & GSEA$padj >= 0.001] <- 0.5
  
  
  
  #Plot and save
  p <- ggplot(GSEA, mapping = aes(x = pathway,
                                  y= ylabel, size=abs)) +
    geom_point(alpha = GSEA$transparency, aes(fill = enrichment, pch = 21)
    ) +
    labs(
      size = "NES magnitude",
      fill = "Enrichment",
      x = "Pathway",
      transparency = "Pvalue") +
    
    guides(colour = guide_legend(order = 1),
           size = guide_legend(order = 2)) +
    scale_shape_identity() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    theme(axis.text = element_text(size = 10))+
    scale_fill_manual(values = c("turquoise3", "salmon"))
  
  
  ggsave(
    paste0(res, "_GSEA plot.pdf"), p, device = "pdf", width = 10, height =15
  )
  
  
}


#######################################################################################
# Investigate genes with poor concordance

# Get the residuals for linear regression in the control and stimulated data
ctrl_model <- lm(scRNAseq ~ proteomics, data = cor_df_ctrl) 
ctrl_residuals <- data.frame(gene = cor_df_ctrl$gene, residual = residuals(ctrl_model))
stim_model <- lm(scRNAseq ~ proteomics, data = cor_df_stim) 
stim_residuals <- data.frame(gene = cor_df_stim$gene, residual = residuals(stim_model))

# Get the absolute value of those residualls to find genes with the greatest deviation
ctrl_residuals$abs <- abs(ctrl_residuals$residual)
stim_residuals$abs <- abs(stim_residuals$residual)

# Get the 90th percentile threshold values
ctrl_90th_percentile <- quantile(ctrl_residuals$abs, probs=0.98, na.rm=TRUE)
stim_90th_percentile <- quantile(stim_residuals$abs, probs = 0.98, na.rm = T)

# Identify low concordance genes
ctrl_low_concordance <- ctrl_residuals[ctrl_residuals$abs >= ctrl_90th_percentile,]
stim_low_concordance <- stim_residuals[stim_residuals$abs >= stim_90th_percentile,]

# Arrange by the absolute value
ctrl_low_concordance <- ctrl_low_concordance %>% arrange(-abs)
stim_low_concordance <- stim_low_concordance %>% arrange(-abs)

# Save the gene lists
low_concord_genes_ctrl <- ctrl_low_concordance$abs
names(low_concord_genes_ctrl) <- ctrl_low_concordance$gene
low_concord_genes_stim <- stim_low_concordance$abs
names(low_concord_genes_stim) <- stim_low_concordance$gene

# Function for running GSEA on the low concordance genes
low_concordance_GSEA <- function(string){ # Give a string, either ctrl or stim
  set.seed(42)
  
  # Hallmark GSEA
  gsea_out_h <- fgsea(h_gene_sets, stats = get(paste0("low_concord_genes_", string)), minSize = 5,
                      scoreType = "pos")
  
  set.seed(42)
  
  # c5 GSEA
  gsea_out_c5 <- fgsea(C5_gene_sets, stats = get(paste0("low_concord_genes_", string)), minSize = 5, scoreType = "pos")
  
  # Save top 20 pathways by p-value and decreasing NES
  gsea_out <- rbind(gsea_out_h, gsea_out_c5) %>% arrange(padj, -NES)
  gsea_out <- gsea_out[1:20,]
  
  # Save data
  df <- apply(gsea_out ,2,as.character)
  write.table(df, file = paste0(string, "_lowconcordance_gsea_result.tsv"), quote = F, sep = "\t")
  
  # GSEA plotting 
  # Load data and re-format
  GSEA <- gsea_out
  
  # Add some additional annotations for plotting
  GSEA$abs <- abs(as.numeric(GSEA$NES))
  
  # Annotate which pathways were enriched in ctrl vs stim (fill color)
  GSEA$enrichment <- NA
  GSEA$enrichment[GSEA$NES < 0] <- "Enriched in Control"
  GSEA$enrichment[GSEA$NES> 0] <- "Enriched in Simulated"
  
  # Y-axis needs a generic label; will only have 1 value
  GSEA$ylabel <- "label"
  
  # Transparency of bubbles indicates significance levels
  GSEA$transparency <- NA
  GSEA$padj <- as.numeric(GSEA$padj)
  GSEA$transparency[GSEA$padj < 0.05 & GSEA$padj >= 0.01] <- 1
  GSEA$transparency[GSEA$padj < 0.01 & GSEA$padj >= 0.001] <- 0.5
  
  
  #Plot and save
  p <- ggplot(GSEA, mapping = aes(x = pathway,
                                  y= ylabel, size=abs)) +
    geom_point(alpha = GSEA$transparency, aes(fill = enrichment, pch = 21)
    ) +
    labs(
      size = "NES magnitude",
      fill = "Enrichment",
      x = "Pathway",
      transparency = "Pvalue") +
    
    guides(colour = guide_legend(order = 1),
           size = guide_legend(order = 2)) +
    scale_shape_identity() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    theme(axis.text = element_text(size = 10))+
    scale_fill_manual(values = c("turquoise3", "salmon"))
  
  
  ggsave(paste0(string, "_low concordance_GSEA plot.pdf")
    , p, device = "pdf", width = 10, height =15
  )
  
}

# Run function
low_concordance_GSEA("ctrl")
low_concordance_GSEA("stim")

######################################################################################
####################################################################################
# Proteomics analysis
# Generate a PCA plot comparing control to stimulated proteomics data
proteomics_data3 <- data.frame(t(prot_data_final2))
proteomics_data3 <- proteomics_data3[-11,]
proteomics_data3 <- data.frame(sapply(proteomics_data3, as.numeric))
colnames(proteomics_data3) <- rownames(prot_data_final2)
proteomics_data3$TREATMENT <- c(rep("Ctrl", 5), rep("Stim", 5))
pca_res <- prcomp(proteomics_data3[1:3974], scale. = F)
pca <- autoplot(pca_res, data = proteomics_data3, color = "TREATMENT",)+theme(text = element_text(size = 10))+
  theme_bw()+theme(aspect.ratio = 1)

setwd("<YOUR RESULTS PATH>")
ggsave("proteomics_pca.pdf", pca, device = "pdf", height = 4, width = 4)

# Generate a Volcano plot based on the DEP analysis differentially
# abundant proteins
res2 <- data_results
res2 <- na.omit(res2)

res2$minuslog10p <- -log10(res2$Stim_vs_Ctrl_p.adj)

res2$direction <- NA

res2$direction[res2$Stim_vs_Ctrl_ratio > 0] <- "UP"
res2$direction[res2$Stim_vs_Ctrl_ratio < 0] <- "DOWN"

# Only add gene names to the most differentially aabundant proteins
res2$label <- NA
res2$label <- res2$name
res2$abs <- abs(res2$Stim_vs_Ctrl_ratio)

# Make the volcano plot and save
volcano <- ggplot(data=res2, aes(x=Stim_vs_Ctrl_ratio, y=minuslog10p, col=direction, label = label)) + 
  geom_point(size = 1)+
  xlim(c(-7.5, 7.5))+
  theme_bw()+
  theme(aspect.ratio = 1)+
  geom_text_repel()
ggsave("prot_volcano.pdf", volcano, device = "pdf", width = 8, height = 4)
write.xlsx(volcano$data, "volcanocoords_ASC.xlsx")

# Heatmap of all proteins control vs. stimulated
proteomics <- log1p(prot_data_final2[1:10])
scaled_prot <- scale(proteomics)
allprots <- pheatmap(scaled_prot,
                     cluster_cols =F, color = hcl.colors(30, "Plasma"))

# Heatmap of differentially abundant proteins control vs. stimulated
res3 <- na.omit(res2[res2$Stim_vs_Ctrl_p.adj < 0.05,])
res4 <- res3[order(res2$abs, decreasing = T),]
de_heatmap <- proteomics[rownames(proteomics) %in% res3$name,]
deprots <- pheatmap(de_heatmap, color = hcl.colors(30, "Plasma"))

# Heatmap of genes/proteins involved in MSC immunomodulation
imm_heatmap <- proteomics[rownames(proteomics) %in% res4$name[1:50],]
imm_map <- pheatmap(imm_heatmap, color = hcl.colors(30, "Plasma"))

ggsave("allprots2.pdf", allprots, device = "pdf", width = 7, height = 15)
ggsave("deprots3.pdf", deprots, device = "pdf", width = 7, height = 7)
ggsave("immprots.pdf", imm_map, device = "pdf", width = 7, height = 7)

ggsave("allprots2.pdf", allprots, device = "pdf", width = 7, height = 15)
ggsave("deprots3.pdf", deprots, device = "pdf", width = 7, height = 7)
ggsave("immprots.pdf", imm_map, device = "pdf", width = 7, height = 7)


#######################################################################################
# Scissor integration of Cultured and P0 cells
# Create treatment annotations for the data
treatment <- c(0, 0, 0, 0, 0, 1, 1, 1, 1, 1)

# Get the proteomics data that will be used to integrate
prot_scissor <- as.matrix(prots_for_scissor)
rownames(prot_scissor) <- rownames(prots_for_scissor)

# Run Scissor analysis on the D25P0 single cell data
phenotype <- treatment
tag <- c('Control', 'Stimulated')

# Add in validation data
# Create Seurat Object
atlas1 <- Read10X("/Users/addie/Partners HealthCare Dropbox/Adrienne Parsons/ASC scRNAseq Proteomics/Additional data/Atlas1", gene.column = 2, cell.column = 1)
atlas1 <- CreateSeuratObject(atlas1)

# Meetadata
mda1 <- read_table("/Users/addie/Partners HealthCare Dropbox/Adrienne Parsons/ASC scRNAseq Proteomics/Additional data/Atlas1/metadata.tsv")
rownames(mda1) <- mda1$cell_id
atlas1a <- atlas1[which(colnames(atlas1) %in% rownames(mda1))]
mda1 <- mda1[which(mda1$cell_id %in% colnames(atlas1a)),]
atlas1 <- AddMetaData(atlas1a, mda1)

# Pre-processing for sc data
atlas1 <- NormalizeData(atlas1)
atlas1 <- FindVariableFeatures(atlas1)
atlas1 <- ScaleData(atlas1)
atlas1 <- RunPCA(atlas1)
atlas1 <- FindNeighbors(atlas1) 
atlas1 <- FindClusters(atlas1, resolution = 0.6)
atlas1 <- RunUMAP(atlas1, dims = 1:15)
atlas1 <- RunAzimuth(atlas1, reference = "adiposeref")

# Get the unique cell types identified for each cluster
for(cluster in unique(atlas1@meta.data$RNA_snn_res.0.6)){ 
  print(cluster)
  print(atlas1@meta.data$predicted.celltype.l1[atlas1@meta.data$RNA_snn_res.0.6 == cluster] %>% table())
}

# Assign a cell type to each cluster (resolution 0.6) based on consensus 
atlas1@meta.data$celltype_major <- NA
for(cluster in unique(atlas1$RNA_snn_res.0.6)){
  print(cluster)
  tbl <- as.data.frame(atlas1@meta.data$predicted.celltype.l1[atlas1@meta.data$RNA_snn_res.0.6 == cluster] %>% table())
  atlas1@meta.data$celltype_major[atlas1@meta.data$RNA_snn_res.0.6 == cluster] <- as.character(tbl[which(tbl$Freq == max(tbl$Freq)), 1])
}


# Scissor is only compatible with v4 assays
D25P02 <- D25P0
atlas2 <- subset(atlas1, subset = celltype_major == "ASPC")
D25P02[["RNA"]] <- as(object = D25P02[["RNA"]], Class = "Assay")
atlas2[["RNA"]] <- as(object = atlas2[["RNA"]], Class = "Assay")

# Save data
setwd("/Users/addie/desktop")
saveRDS(atlas2, "Atlas1ASCs.rds")
saveRDS(prot_scissor, "Protscissor.rds")

# Run for original data
infos <- Scissor(prot_scissor, D25P02, phenotype, tag = tag, alpha = 0.5, 
                 family = "binomial", Save_file = "Scissor_D25P0.RData")

Scissor_select <- rep(0, ncol(D25P02))
names(Scissor_select) <- colnames(D25P02)
Scissor_select[infos$Scissor_pos] <- 1
Scissor_select[infos$Scissor_neg] <- 2
D25P02 <- AddMetaData(D25P02, metadata = Scissor_select, col.name = "scissor")
Scissor_D25P02 <- DimPlot(D25P02, reduction = 'umap', group.by = 'scissor', cols = 
                           c('grey','indianred1','royalblue'), pt.size = 1.2, order = c(2,1))+ theme(aspect.ratio = 1)

# Save UMAP
ggsave("D25P0 Scissor.pdf", Scissor_D25P02, device = "pdf")

# Repeat for validation data
infos <- Scissor(prot_scissor, atlas2, phenotype, tag = tag, alpha = 0.5, 
                 family = "binomial", Save_file = "Scissor_D25P0.RData")

Scissor_select <- rep(0, ncol(atlas2))
names(Scissor_select) <- colnames(atlas2)
Scissor_select[infos$Scissor_pos] <- 1
Scissor_select[infos$Scissor_neg] <- 2
atlas2 <- AddMetaData(atlas2, metadata = Scissor_select, col.name = "scissor")
Scissor_atlas2 <- DimPlot(atlas2, reduction = 'umap', group.by = 'scissor', cols = 
                            c('grey','indianred1','royalblue'), pt.size = 1.2, order = c(2,1))+ theme(aspect.ratio = 1)

# Save UMAP
ggsave("Atlas1 Scissor.pdf", Scissor_atlas2, device = "pdf")

# Repeat for cultured cells
Cultured <- NormalizeData(Cultured) %>% ScaleData(.)
Cultured2 <- Cultured
Cultured2[["RNA"]] <- as(object = Cultured2[["RNA"]], Class = "Assay")
infos_cultured <- Scissor(prot_scissor, Cultured2, phenotype, tag = tag, alpha = 0.5, 
                          family = "binomial", Save_file = "Scissor_D25Cultured.RData")
Scissor_select <- rep(0, ncol(Cultured))
names(Scissor_select) <- colnames(Cultured)
Scissor_select[infos_cultured$Scissor_pos] <- 1
Scissor_select[infos_cultured$Scissor_neg] <- 2
Cultured <- AddMetaData(Cultured, metadata = Scissor_select, col.name = "scissor")
Scissor_Cultured <- DimPlot(Cultured, reduction = 'umap', group.by = 'scissor', cols = 
                              c('grey','indianred1','royalblue'), pt.size = 1.2, order = c(2,1))+ theme(aspect.ratio = 1)

# Save UMAP
ggsave("D25_Cultured Scissor.pdf", Scissor_Cultured, device = "pdf")

# Identify the DE genes between ASCs determined to be Scissor Positive and
# Scissor Negative in both originaal and validation data
D25P0$scissor <- D25P02@meta.data$scissor

ASC_only <- subset(D25P0, subset = celltype_final == "ASC Pre-adipocyte" |
                     celltype_final == "Fibro-ASC" | celltype_final == "ASC Other")

Idents(ASC_only) <- "scissor"
Idents(atlas2) <- "scissor"
scissor.markers <- FindMarkers(ASC_only, ident.1 = 1, ident.2 = c(2))
scissor.markers <- scissor.markers[scissor.markers$p_val_adj < 0.05,]
scissor.markers$gene <- rownames(scissor.markers)

# Cross-reference the statistically significant genes to the cell surface
# protein atlas
setwd("<YOUR DATA PATH>")
atlas <- read_excel("./table_S3_surfaceome.xlsx", skip = 1)
atlas <- atlas$`UniProt gene`[atlas$`Surfaceome Label` == "surface"]

# Get the cell surface proteins
cell_surface_proteins <- scissor.markers$gene[scissor.markers$gene %in% atlas]

# Identify the scissor genes that arre cell surface genes and save
scissor_surface.markers <- scissor.markers[rownames(scissor.markers) %in% cell_surface_proteins,]
write.csv(scissor_surface.markers, file = "P0scissor_surface.markers.csv")

genes <- atlas[atlas %in% rownames(atlas2)]

atlas.scissor.markers <- FindMarkers(atlas2, ident.1 = 1, ident.2 = c(2), features=intersect(rownames(atlas2), genes))
write.csv(atlas.scissor.markers, "Validation DE genes.csv")

######################################################################################
# CellChat analysis of scissor-positive cells
View(D25P0@meta.data)

# Change the final cell type and major cell type to scissor+ and scissor- ASCs for those 
# that are +/-
# 1 is positive, 2 is negative
ASCs <- rownames(D25P0@meta.data)[grep("ASC", D25P0@meta.data$celltype_final)]
D25P0@meta.data$celltype_final[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 1)] <- paste0(D25P0@meta.data$celltype_final[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 1)], "_scissorpositive")
D25P0@meta.data$celltype_final[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 2)] <- paste0(D25P0@meta.data$celltype_final[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 2)], "_scissornegative")

D25P0@meta.data$celltype_major[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 1)] <- paste0(D25P0@meta.data$celltype_major[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 1)], "_scissorpositive")
D25P0@meta.data$celltype_major[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 2)] <- paste0(D25P0@meta.data$celltype_major[which(rownames(D25P0@meta.data) %in% ASCs & D25P0@meta.data$scissor == 2)], "_scissornegative")

# Make a celltype final CellChat object
Idents(D25P0) <- "celltype_final"
cellChat_cf <- createCellChat(object = D25P0, group.by = "ident", assay = "RNA")

Idents(D25P0) <- "celltype_major"
cellChat_cm <- createCellChat(object = D25P0, group.by = "ident", assay = "RNA")

# CellChat setup
CellChatDB <- CellChatDB.human
CellChatDB.use <- CellChatDB
future::plan("multisession", workers = 4) # do parallel

# For eiether object
for(obj in c("cellChat_cf" ,"cellChat_cm")){
  print(obj)
  cellchat <- get(obj)
  cellchat@DB <- CellChatDB.use
  
  # CellChat communication probability calculation
  cellchat <- subsetData(cellchat)
  print("identifying over expressed genes")
  cellchat <- identifyOverExpressedGenes(cellchat)
  print("identifying over expressed interactions")
  cellchat <- identifyOverExpressedInteractions(cellchat)
  print("calculating communication probabilities")
  cellchat <- computeCommunProb(cellchat, type = "triMean")
  print("filtering...")
  cellchat <- filterCommunication(cellchat, min.cells = 3)
  print("computing pathways")
  cellchat <- computeCommunProbPathway(cellchat)
  print("finalizing...")
  cellchat <- aggregateNet(cellchat)
  
  assign(obj, cellchat)
}

# Circle plots
netVisual_circle(cellChat_cf@net$count, weight.scale = T, label.edge= F, title.name = "Number of interactions")
netVisual_circle(cellChat_cf@net$weight, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")
netVisual_circle(cellChat_cm@net$count, weight.scale = T, label.edge= F, title.name = "Number of interactions")
netVisual_circle(cellChat_cm@net$weight, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")
cellChat_cf <- netAnalysis_computeCentrality(cellChat_cf)
cellChat_cm <- netAnalysis_computeCentrality(cellChat_cm)

# Signaling role scatter
netAnalysis_signalingRole_scatter(cellChat_cf)
netAnalysis_signalingRole_scatter(cellChat_cm)

setwd("<YOUR DATA PATH>")
saveRDS(cellChat_cf, "cellChat.cf.rds")
saveRDS(cellChat_cm, "cellChat.cm.rds")


setwd("<YOUR RESULTS PATH>./cm")
for(pw in cellChat_cm@netP$pathways){
    pdf(paste(pw, ".pdf", sep = ""))
    print(netVisual_aggregate(object = cellChat_cm, layout = "circle", signaling = as.character(pw)))
    dev.off()
}

setwd("<YOUR RESULTS PATH>./cf")
for(pw in cellChat_cf@netP$pathways){
  pdf(paste(pw, ".pdf", sep = ""))
  print(netVisual_aggregate(object = cellChat_cf, layout = "circle", signaling = as.character(pw)))
  dev.off()
}


#######################################################################################
# Monocle trajectory analysis for Stimulated cells
# Monocle standard pipeline
cds <- as.cell_data_set(Cultured)
cds <- cluster_cells(cds, resolution = 0.001)
cds <- learn_graph(cds, use_partition = F, verbose = T)

# Plot the trajectory
traj <- plot_cells(cds,
                   color_cells_by = "cluster",
                   label_groups_by_cluster=FALSE,
                   label_leaves=FALSE,
                   label_branch_points=FALSE)+theme(aspect.ratio = 1)

setwd("<YOUR RESULTS PATH>")
ggsave("trajectory_monocle.pdf", traj, device = "pdf")

# Pseudotimme
cds <- order_cells(cds)
plot_cells(cds,
           color_cells_by = "pseudotime",
           group_cells_by = "cluster",
           label_cell_groups = FALSE,
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           label_roots = FALSE,
           trajectory_graph_color = "grey60")

traj.plot <- plot_cells(cds,
                        color_cells_by = "pseudotime",
                        group_cells_by = "cluster",
                        label_cell_groups = FALSE,
                        label_groups_by_cluster=FALSE,
                        label_leaves=FALSE,
                        label_branch_points=FALSE,
                        label_roots = FALSE,
                        trajectory_graph_color = "grey60")+theme(aspect.ratio = 1)

ggsave("pseudotime.pdf", traj.plot, device = "pdf")

# Get the pseudotime values for correlation
point.data <- ggplot_build(traj.plot)[["plot"]][["data"]]
pseudotime <- data.frame(point.data$cell_color)
rownames(pseudotime) <- rownames(point.data)

# Add to the Seurat Object
Cultured <- AddMetaData(Cultured, pseudotime)

#Get gene lists for AddModuleScore
setwd("<YOUR DATA PATH>")
hallmarks <- fgsea::gmtPathways("./h.all.v7.4.symbols.gmt")
c5 <- fgsea::gmtPathways("./c5.all.v2023.2.Hs.symbols.gmt")
c2 <- fgsea::gmtPathways("./gmts/c2.all.v2023.2.Hs.symbols.gmt")

# Correlate enrichment score (module score) to pseudotime by cluster
setwd("<YOUR RESULTS PATH>/Pseudotime_cors")

# Initialize an emmpty data frame
pseudocors <- data.frame("Pathway" = character(0), 
                        "Cor" = numeric(0),
                        "Pval" = numeric(0))

# For each pathway:
for(pathway in names(hallmarks)){
  print(pathway)
  
  # Assign a signature score to every celll
  mod <- AddModuleScore(Cultured, hallmarks[pathway])
  
  # Initialize an emmpty list to populate with scores and pseudotime
  pseudo_list <- list()
  modscore_list <- list()
  
  # For each cell type:
  for(type in unique(mod$celltype_final)){
    # Get the average psuedotime and mmodule score
    avg_pseudo <- mean(mod@meta.data$point.data.cell_color[mod@meta.data$celltype_final == type])
    avg_mod <- mean(mod@meta.data$Cluster1[mod@meta.data$celltype_final == type])
    
    # Add to the list
    pseudo_list <- append(pseudo_list, avg_pseudo)
    modscore_list <- append(modscore_list, avg_mod)
  }
  
  # Run correlation
  cor <- cor.test(as.numeric(pseudo_list), as.numeric(modscore_list))
  
  # Make a vector of correlation results
  corvec <- list("Pathway" = pathway, "Cor" = cor$estimate, "Pval" = cor$p.value)
  
  # Add the vector to the datta frame
  pseudocors <- rbind(pseudocors, corvec)
  
  if(cor$p.value < 0.05){
    print(cor)
  }
}

# Adjust p-values
pseudocors$padj <- p.adjust(pseudocors$Pval, method = "BH")

# Get the significant pathways
pathways_of_interest <- pseudocors$Pathway[pseudocors$padj < 0.05]

# Save correlation plots for the significant ones
setwd("<YOUR RESULTS PATH>/Pseudotime_cors")

# For each significant pathway:
for(pathway in pathways_of_interest){
  print(pathway)
  
  # Assign the module score to each cell
  mod <- AddModuleScore(Cultured, hallmarks[pathway])
  
  # Initialize empty lists to populate with modulle score and pseudotime averages
  pseudo_list <- list()
  modscore_list <- list()
  
  # For each cell type
  for(type in unique(mod$celltype_final)){
    # Get the mean pseudotime and module score
    avg_pseudo <- mean(mod@meta.data$point.data.cell_color[mod@meta.data$celltype_final == type])
    avg_mod <- mean(mod@meta.data$Cluster1[mod@meta.data$celltype_final == type])
    
    # Add it to the list
    pseudo_list <- append(pseudo_list, avg_pseudo)
    modscore_list <- append(modscore_list, avg_mod)
  }
   # Correlate
  cor <- cor.test(as.numeric(pseudo_list), as.numeric(modscore_list))
  
  # When significant, save a plot
  if(cor$p.value < 0.05){
    df <- data.frame("pseudo" = unlist(pseudo_list), "mod" = unlist(modscore_list))
    plt <- ggplot(df, aes(x = pseudo, y = mod))+geom_point()+xlab("Pseudotime")+ylab("Pathway Module Score")+
      ggtitle(pathway)+geom_smooth(method = "lm")+theme_minimal()+theme(aspect.ratio = 1)
    ggsave(paste0(pathway, ".pdf"), plt, device = "pdf")
  }
}

###################################################################################
